---
layout: post
title: Direct3D 11をセットアップする
category: DirectX11
---

Direct3D 11を使えるようにセットアップしてみましょう。Direct3D 11を使うとWindowsで3Dの描画が出来ます。Direct3D 11のセットアップは`D3D11CreateDeviceAndSwapChain`という関数を呼べばできます。というと簡単そうですが、DirectX 11に対応してるかどうかは環境によって違うのでちょっと面倒くさいです。例えばこのPCにはDirectX 11に対応したGPUがあるのでGPUを使いましょう、このPCにはGPUがないのでソフトウェアの力でDirectX 11を動かしましょうみたいな感じで環境によって変えないといけません。

``` cpp
    std::vector<D3D_DRIVER_TYPE> driverTypes
    {
        D3D_DRIVER_TYPE_HARDWARE,
        D3D_DRIVER_TYPE_WARP,
        D3D_DRIVER_TYPE_REFERENCE,
        D3D_DRIVER_TYPE_SOFTWARE,
    };

    std::vector<D3D_FEATURE_LEVEL> featureLevels
    {
        D3D_FEATURE_LEVEL_11_0,
        D3D_FEATURE_LEVEL_10_1,
        D3D_FEATURE_LEVEL_10_0,
    };

    DXGI_SWAP_CHAIN_DESC swapChainDesc = {};
    swapChainDesc.BufferDesc.Width = Window::GetSize().x;
    swapChainDesc.BufferDesc.Height = Window::GetSize().y;
    swapChainDesc.BufferDesc.RefreshRate.Numerator = 60;
    swapChainDesc.BufferDesc.RefreshRate.Denominator = 1;
    swapChainDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    swapChainDesc.SampleDesc.Count = 1;
    swapChainDesc.SampleDesc.Quality = 0;
    swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
    swapChainDesc.BufferCount = 1;
    swapChainDesc.OutputWindow = Window::GetHandle();
    swapChainDesc.Windowed = true;

    Microsoft::WRL::ComPtr<ID3D11Device> device;
    Microsoft::WRL::ComPtr<ID3D11DeviceContext> context;
    Microsoft::WRL::ComPtr<IDXGISwapChain> swapChain;

    for (size_t i = 0; i < driverTypes.size(); i++)
    {
        HRESULT r = D3D11CreateDeviceAndSwapChain(nullptr, driverTypes[i], nullptr, 0, featureLevels.data(), (UINT)featureLevels.size(), D3D11_SDK_VERSION, &swapChainDesc, swapChain.GetAddressOf(), device.GetAddressOf(), nullptr, context.GetAddressOf());

        if (SUCCEEDED(r))
            break;
    }
```

コードはこんな感じです。`driverTypes`というのを下のfor文で回してハードウェアを優先して使うようにしてます。`featureLevels`も同じようなものですが、こっちはD3D11CreateDeviceAndSwapChain関数が勝手にやってくれるので、関数に渡すだけです。

Direct3D 11のセットアップはこれだけなので、これをクラスにしてみましょう。Graphics.hppとGraphics.cppというファイルを作ってください。

``` cpp
// Graphics.hpp
#pragma once
#include <d3d11.h>
#include <wrl.h>
#pragma comment(lib, "d3d11.lib")

class Graphics
{
public:
    static void Initialize();
    static ID3D11Device& GetDevice();
    static ID3D11DeviceContext& GetContext();
    static IDXGISwapChain& GetSwapChain();
    static void Update();

private:
    static Microsoft::WRL::ComPtr<ID3D11Device> device;
    static Microsoft::WRL::ComPtr<ID3D11DeviceContext> context;
    static Microsoft::WRL::ComPtr<IDXGISwapChain> swapChain;
};
```

``` cpp
// Graphics.cpp
#include <vector>
#include "Window.hpp"
#include "Graphics.hpp"

Microsoft::WRL::ComPtr<ID3D11Device> Graphics::device;
Microsoft::WRL::ComPtr<ID3D11DeviceContext> Graphics::context;
Microsoft::WRL::ComPtr<IDXGISwapChain> Graphics::swapChain;

void Graphics::Initialize()
{
    std::vector<D3D_DRIVER_TYPE> driverTypes
    {
        D3D_DRIVER_TYPE_HARDWARE,
        D3D_DRIVER_TYPE_WARP,
        D3D_DRIVER_TYPE_REFERENCE,
        D3D_DRIVER_TYPE_SOFTWARE,
    };

    std::vector<D3D_FEATURE_LEVEL> featureLevels
    {
        D3D_FEATURE_LEVEL_11_0,
        D3D_FEATURE_LEVEL_10_1,
        D3D_FEATURE_LEVEL_10_0,
    };

    DXGI_SWAP_CHAIN_DESC swapChainDesc = {};
    swapChainDesc.BufferDesc.Width = Window::GetSize().x;
    swapChainDesc.BufferDesc.Height = Window::GetSize().y;
    swapChainDesc.BufferDesc.RefreshRate.Numerator = 60;
    swapChainDesc.BufferDesc.RefreshRate.Denominator = 1;
    swapChainDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    swapChainDesc.SampleDesc.Count = 1;
    swapChainDesc.SampleDesc.Quality = 0;
    swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
    swapChainDesc.BufferCount = 1;
    swapChainDesc.OutputWindow = Window::GetHandle();
    swapChainDesc.Windowed = true;

    for (size_t i = 0; i < driverTypes.size(); i++)
    {
        HRESULT r = D3D11CreateDeviceAndSwapChain(nullptr, driverTypes[i], nullptr, 0, featureLevels.data(), (UINT)featureLevels.size(), D3D11_SDK_VERSION, &swapChainDesc, swapChain.GetAddressOf(), device.GetAddressOf(), nullptr, context.GetAddressOf());

        if (SUCCEEDED(r))
            break;
    }
}

ID3D11Device& Graphics::GetDevice()
{
    return *device.Get();
}

ID3D11DeviceContext& Graphics::GetContext()
{
    return *context.Get();
}

IDXGISwapChain& Graphics::GetSwapChain()
{
    return *swapChain.Get();
}

void Graphics::Update()
{
    swapChain->Present(1, 0);
}
```

``` cpp
// Source.cpp
#include "Window.hpp"
#include "Graphics.hpp"

void Initialize()
{
    Window::Initialize();
    Graphics::Initialize();
}

bool Refresh()
{
    Graphics::Update();
    return Window::Update();
}

int APIENTRY wWinMain(HINSTANCE, HINSTANCE, LPWSTR, int)
{
    Initialize();

    while (Refresh())
    {
        // ここにゲームの処理を書いていく
    }

    return 0;
}
```

`#include <d3d11.h>`というのがDirect3D 11を使うためのヘッダファイルなのでインクルードします。`#include <wrl.h>`はDirect3D 11のオブジェクトのためのスマートポインタを使うためにインクルードします。`ID3D11Device`などのDirect3D 11のオブジェクトはCOMというものが使われているのでCOM専用の`Microsoft::WRL::ComPtr`を使います。COMが何なのか知りたい人は調べてみてください。正直、理解してなくても使えるのでここでは説明しません。スマートポインタというのはdeleteを自動でやってくれるすごいポインタです。C++はdeleteし忘れるとメモリークしてしまうので、それを防げます。`ID3D11Device`はテクスチャとかシェーダなどいろいろなものを作るやつで、`ID3D11DeviceContext`はテクスチャとかシェーダなどを使うためのやつで、`IDXGISwapChain`は実際に画面に描画するためのやつです。GraphicsクラスのUpdate関数の中の`swapChain->Present(1, 0);`で描画してます。Source.cppもちょっと変えてます。ただこれを実行しても、背景が黒くなっただけであんまり変化がないので、出来てるのか分からないですね…ダウンロードしたい人はGitHubに[サンプルリポジトリ](https://github.com/itukikikuti/DirectX11Sample)があるので、ぜひダウンロードしてください。
