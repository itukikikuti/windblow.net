---
layout: post
title: 行列で座標変換して三角形を動かす
category: DirectX11
date: 2018-11-10 00:00:00
---

次は三角形を動かしてみましょう。どうすれば動かせるんでしょうか。実は頂点を動かせば動きます。

``` cpp
    DirectX::XMFLOAT3 position;

    std::vector<Vertex> vertices;
    vertices.push_back(Vertex(DirectX::XMFLOAT3(position.x, position.y + 1.0f, position.z), DirectX::XMFLOAT3(1.0f, 1.0f, 0.0f)));
    vertices.push_back(Vertex(DirectX::XMFLOAT3(position.x + 1.0f, position.y - 1.0f, position.z), DirectX::XMFLOAT3(0.0f, 1.0f, 1.0f)));
    vertices.push_back(Vertex(DirectX::XMFLOAT3(position.x - 1.0f, position.y - 1.0f, position.z), DirectX::XMFLOAT3(1.0f, 0.0f, 1.0f)));
```

さっき使った3つ頂点の座標にpositionという変数を足してみました。こうすればpositionを動かせば三角形が移動しますよね。でもこのやり方だと、動かすたびに頂点バッファを作り直さないといけないので動作が重くなったり、回転や拡大縮小もしようとすると面倒くさいです。なので他のやり方にします。行列というものを使います。行列というのはお店の前にできる方じゃなくて、数学の方です。私は数学は中学の連立方程式までしかわからないので、詳しい説明は出来ませんが、行列を使うと座標変換が出来ます。「アフィン変換」でググってみてください。これと同じようなことをやれば、移動、回転、拡縮が簡単にできるみたいです。

行列はシェーダで使うので、まずはシェーダに行列を送れるようにしましょう。CBuffer.hppというファイルを作ってください。

<small>CBuffer.hpp</small>
``` cpp
#pragma once
#include <memory>
#include <d3d11.h>
#include <wrl.h>
#include "Graphics.hpp"

template <class T>
class CBuffer
{
public:
    CBuffer()
    {
        data = std::make_unique<T>();

        D3D11_BUFFER_DESC cbufferDesc = {};
        cbufferDesc.ByteWidth = sizeof(T);
        cbufferDesc.Usage = D3D11_USAGE_DEFAULT;
        cbufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
        Graphics::GetDevice().CreateBuffer(&cbufferDesc, nullptr, buffer.GetAddressOf());
    }
    T& Get()
    {
        return *data.get();
    }
    void Attach(int slot)
    {
        Graphics::GetContext().UpdateSubresource(buffer.Get(), 0, nullptr, data.get(), 0, 0);
        Graphics::GetContext().VSSetConstantBuffers(slot, 1, buffer.GetAddressOf());
        Graphics::GetContext().PSSetConstantBuffers(slot, 1, buffer.GetAddressOf());
    }

private:
    Microsoft::WRL::ComPtr<ID3D11Buffer> buffer;
    std::unique_ptr<T> data;
};
```

CBufferクラスはテンプレートクラスなのでヘッダファイルのみです。このクラスは定数バッファと使うためのクラスで、英語でいうとConstant BufferなのでCBufferという名前になってます。ID3D11Device::CreateBuffer関数で定数バッファを作って、ID3D11DeviceContext::UpdateSubresource関数で定数バッファの中身を更新して、ID3D11DeviceContext::VSSetConstantBuffers関数などで定数バッファを設定してます。そしたらMeshクラスにShaderData構造体と`CBuffer<ShaderData> shaderData;`をプライベートで追加してください。

<small>Mesh.hpp</small>
``` cpp
class Mesh
{
    ...
private:
    struct ShaderData
    {
        DirectX::XMMATRIX modelMatrix;
    };

    CBuffer<ShaderData> shaderData;
    Microsoft::WRL::ComPtr<ID3D11Buffer> vertexBuffer;
};
```

さらにMesh::Draw関数をちょっと変えます。

<small>Mesh.cpp</small>
``` cpp
void Mesh::Draw()
{
    static float angle = 0.0f;
    angle += 0.1f;

    shaderData.Get().modelMatrix = DirectX::XMMatrixTranspose(
        DirectX::XMMatrixRotationZ(angle)
    );

    shaderData.Attach(0);

    shader.Attach();
    ...
}
```

さらにシェーダも変えます。Shader::GetDefault関数の中です。

<small>Shader.cpp</small>
``` cpp
Shader Shader::GetDefault()
{
    static std::unique_ptr<Shader> shader(new Shader(
        "cbuffer Object : register(b0)"
        "{"
        "    matrix modelMatrix;"
        "};"
        "struct Vertex"
        ...
        "Pixel VS(Vertex vertex)"
        "{"
        "    Pixel output;"
        "    output.position = mul(vertex.position, modelMatrix);"
        "    output.color = vertex.color;"
        "    return output;"
        "}"
        ...
}
```

`cbuffer Object : register(b0)`を追加して、`output.position = mul(vertex.position, modelMatrix)`に変えました。これで実行してみましょう。三角形がグルグル回りましたね！DirectX::XMMatrixRotationZ関数でZ軸を回転させる行列を作っています。Z軸を回せば正面から見ると平面的に回ります。そしてDirectX::XMMatrixTranspose関数で転置行列にしてからmodelMatrixに渡しています。理由は私もよくわからないですが、とりあえず転置行列を使っている人が多かった気がするので使ってます。シェーダのmulという関数は行列を掛け合わせる関数です。`shaderData.Attach(0);`で0を渡してますがこの0の意味は`cbuffer Object : register(b0)`のb0のことです。これはスロットというものなんですが、b0の定数バッファにデータを設定したければ、Attach関数に0を渡します。`cbuffer Object : register(b2)`にデータを設定するときは`shaderData.Attach(2);`というふうにすればいい感じです。

さて、行列を使えば回転だけでなく、移動、拡大縮小もできます。

``` cpp
    DirectX::XMMATRIX translationMatrix = DirectX::XMMatrixTranslation(position.x, position.y, position.z);

    DirectX::XMMATRIX rotationMatrix = DirectX::XMMatrixRotationRollPitchYaw(
        DirectX::XMConvertToRadians(rotation.x),
        DirectX::XMConvertToRadians(rotation.y),
        DirectX::XMConvertToRadians(rotation.z)
    );

    DirectX::XMMATRIX scalingMatrix = DirectX::XMMatrixScaling(scale.x, scale.y, scale.z);

    shaderData.Get().modelMatrix = DirectX::XMMatrixTranspose(
        scalingMatrix * rotationMatrix * translationMatrix
    );
```

DirectX::XMMatrixTranslation関数で平行移動行列、DirectX::XMMatrixRotationRollPitchYaw関数で回転行列、DirectX::XMMatrixScaling関数で拡大縮小行列を計算できます。この行列たちを掛け合わせて`shaderData.Get().modelMatrix`に渡せば移動、回転、拡大縮小が自由自在にできます。ちなみにさっきはDirectX::XMMatrixRotationZ関数を使いましたがこれはZ軸しか回転できないのでDirectX::XMMatrixRotationRollPitchYaw関数を使ってXYZ軸全て回転できるようにしています。RollはZ軸、PitchはX軸、YawはY軸のことで、ZXYの順に回転させています。DirectX::XMConvertToRadians関数は度数をラジアンに変換するものです。DirectX::XMMatrixRotationRollPitchYaw関数などにはラジアン角を渡さないといけないので変換しています。ラジアン角とは簡単に言うと度数は一周が360°ですがラジアンは一周が2πです。つまり180°=πです。詳しくは「ラジアン角」でググってください。

拡大縮小行列、回転行列、平行移動行列という順で掛け合わせていますが、これにも意味があります。2Dで考えてみるとわかりやすいですが、例えば座標が(1,0)、回転が10°、スケールが(1,2)というふうに動かすとします。そのときに行列を移動、回転、拡縮という順番で掛け合わせると、なんか思ったようになってくれません。拡縮、回転、移動の順番で掛け合わせると思ったとおりになってくれます。これは回転の順番も同じです。ゲームではZXYの順番で回転させるのが、無難です。

これを踏まえてクラスを変えていきます。ちなみに変更したところだけ載せるので、コードを全部見たい方は[https://github.com/itukikikuti/DirectX11Sample](https://github.com/itukikikuti/DirectX11Sample)

<small>Mesh.hpp</small>
``` cpp
#pragma once
#include <vector>
#include <d3d11.h>
#include <DirectXMath.h>
#include <wrl.h>
#include "Cbuffer.hpp"
#include "Shader.hpp"

...

class Mesh
{
public:
    DirectX::XMFLOAT3 position;
    DirectX::XMFLOAT3 rotation;
    DirectX::XMFLOAT3 scale;
    std::vector<Vertex> vertices;
    Shader shader = Shader::GetDefault();

    Mesh();
    void Draw();

private:
    struct ShaderData
    {
        DirectX::XMMATRIX modelMatrix;
    };

    CBuffer<ShaderData> shaderData;
    Microsoft::WRL::ComPtr<ID3D11Buffer> vertexBuffer;
};
```

`DirectX::XMFLOAT3 position;`と`DirectX::XMFLOAT3 rotation;``DirectX::XMFLOAT3 scale;`と`CBuffer<ShaderData> shaderData;`を追加しています。

<small>Mesh.cpp</small>
``` cpp
Mesh::Mesh()
{
    position = DirectX::XMFLOAT3(0.0f, 0.0f, 0.0f);
    rotation = DirectX::XMFLOAT3(0.0f, 0.0f, 0.0f);
    scale = DirectX::XMFLOAT3(1.0f, 1.0f, 1.0f);

    vertices.push_back(Vertex(DirectX::XMFLOAT3(0.0f, 1.0f, 0.0f), DirectX::XMFLOAT3(1.0f, 1.0f, 0.0f)));
    vertices.push_back(Vertex(DirectX::XMFLOAT3(1.0f, -1.0f, 0.0f), DirectX::XMFLOAT3(0.0f, 1.0f, 1.0f)));
    vertices.push_back(Vertex(DirectX::XMFLOAT3(-1.0f, -1.0f, 0.0f), DirectX::XMFLOAT3(1.0f, 0.0f, 1.0f)));

    D3D11_BUFFER_DESC vertexBufferDesc = {};
    vertexBufferDesc.ByteWidth = sizeof(Vertex) * (UINT)vertices.size();
    vertexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
    vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;

    D3D11_SUBRESOURCE_DATA vertexSubresourceData = {};
    vertexSubresourceData.pSysMem = vertices.data();

    Graphics::GetDevice().CreateBuffer(&vertexBufferDesc, &vertexSubresourceData, vertexBuffer.GetAddressOf());
}

void Mesh::Draw()
{
    shaderData.Get().modelMatrix = DirectX::XMMatrixTranspose(
        DirectX::XMMatrixScaling(scale.x, scale.y, scale.z) *
        DirectX::XMMatrixRotationRollPitchYaw(
            DirectX::XMConvertToRadians(rotation.x),
            DirectX::XMConvertToRadians(rotation.y),
            DirectX::XMConvertToRadians(rotation.z)
        ) *
        DirectX::XMMatrixTranslation(position.x, position.y, position.z)
    );

    shaderData.Attach(0);

    shader.Attach();

    UINT stride = sizeof(Vertex);
    UINT offset = 0;
    Graphics::GetContext().IASetVertexBuffers(0, 1, vertexBuffer.GetAddressOf(), &stride, &offset);

    Graphics::GetContext().IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

    Graphics::GetContext().Draw((UINT)vertices.size(), 0);
}
```

コンストラクタでposition、rotation、scaleの初期化をしているのと、Draw関数でモデル行列の計算と、`shaderData.Attach(0);`を追加しています。

<small>Shader.cpp</small>
``` cpp
Shader Shader::GetDefault()
{
    static std::unique_ptr<Shader> shader(new Shader(
        "cbuffer Object : register(b0)"
        "{"
        "    matrix modelMatrix;"
        "};"
        "cbuffer Camera : register(b1)"
        "{"
        "    matrix viewMatrix;"
        "    matrix projectionMatrix;"
        "};"
        "struct Vertex"
        "{"
        "    float4 position : POSITION;"
        "    float3 color : COLOR;"
        "};"
        "struct Pixel"
        "{"
        "    float4 position : SV_POSITION;"
        "    float3 color : COLOR;"
        "};"
        "Pixel VS(Vertex vertex)"
        "{"
        "    Pixel output;"
        "    output.position = mul(vertex.position, modelMatrix);"
        "    output.position = mul(output.position, viewMatrix);"
        "    output.position = mul(output.position, projectionMatrix);"
        "    output.color = vertex.color;"
        "    return output;"
        "}"
        "float4 PS(Pixel pixel) : SV_TARGET"
        "{"
        "    return float4(pixel.color, 1);"
        "}"
    ));

    return *shader.get();
}
```

定数バッファをObjectとCameraの2つ、追加しています。

<small>Camera.hpp</small>
``` cpp
#pragma once
#include <d3d11.h>
#include <DirectXMath.h>
#include <wrl.h>
#include "Cbuffer.hpp"

class Camera
{
public:
    DirectX::XMFLOAT3 position;
    DirectX::XMFLOAT3 rotation;

    Camera();
    void Start();
    void Stop();

private:
    struct ShaderData
    {
        DirectX::XMMATRIX viewMatrix;
        DirectX::XMMATRIX projectionMatrix;
    };

    CBuffer<ShaderData> shaderData;
    Microsoft::WRL::ComPtr<ID3D11RenderTargetView> renderTargetView;
};
```

positionとrotation、定数バッファをを追加しています。

<small>Camera.cpp</small>
``` cpp
Camera::Camera()
{
    position = DirectX::XMFLOAT3(0.0f, 0.0f, 0.0f);
    rotation = DirectX::XMFLOAT3(0.0f, 0.0f, 0.0f);

    Microsoft::WRL::ComPtr<ID3D11Texture2D> texture = nullptr;
    Graphics::GetSwapChain().GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast<void**>(texture.GetAddressOf()));

    Graphics::GetDevice().CreateRenderTargetView(texture.Get(), nullptr, renderTargetView.GetAddressOf());

    D3D11_VIEWPORT viewPort = {};
    viewPort.Width = (float)Window::GetSize().x;
    viewPort.Height = (float)Window::GetSize().y;
    viewPort.MaxDepth = 1.0f;
    Graphics::GetContext().RSSetViewports(1, &viewPort);

    shaderData.Get().projectionMatrix = DirectX::XMMatrixTranspose(
        DirectX::XMMatrixPerspectiveFovLH(
            DirectX::XMConvertToRadians(60.0f),
            (float)Window::GetSize().x / (float)Window::GetSize().y,
            0.1f,
            1000.0f
        )
    );
}

void Camera::Start()
{
    shaderData.Get().viewMatrix = DirectX::XMMatrixTranspose(
        DirectX::XMMatrixInverse(
            nullptr,
            DirectX::XMMatrixRotationRollPitchYaw(
                DirectX::XMConvertToRadians(rotation.x),
                DirectX::XMConvertToRadians(rotation.y),
                DirectX::XMConvertToRadians(rotation.z)
            ) *
            DirectX::XMMatrixTranslation(position.x, position.y, position.z)
        )
    );

    shaderData.Attach(1);

    Graphics::GetContext().OMSetRenderTargets(1, renderTargetView.GetAddressOf(), nullptr);

    float clearColor[4] = { 1.0f, 1.0f, 1.0f, 1.0f };
    Graphics::GetContext().ClearRenderTargetView(renderTargetView.Get(), clearColor);
}
```

コンストラクタでposition、rotationの初期化と射影行列の計算をしています。Start関数でビュー行列の計算と`shaderData.Attach(1);`を追加しています。

<small></small>
``` cpp
#include "Window.hpp"
#include "Graphics.hpp"

#include "CBuffer.hpp"
#include "Shader.hpp"
#include "Camera.hpp"
#include "Mesh.hpp"

void Initialize()
{
    Window::Initialize();
    Graphics::Initialize();
}

bool Refresh()
{
    Graphics::Update();
    return Window::Update();
}

int APIENTRY wWinMain(HINSTANCE, HINSTANCE, LPWSTR, int)
{
    Initialize();

    Camera camera;
    camera.position = DirectX::XMFLOAT3(0.0f, 1.0f, -5.0f);
    camera.rotation = DirectX::XMFLOAT3(10.0f, 0.0f, 0.0f);

    Mesh mesh;

    float temp = 0.0f;

    while (Refresh())
    {
        camera.Start();
        
        temp += 0.1f;

        mesh.position = DirectX::XMFLOAT3(cosf(temp), sinf(temp), 0.0f);
        mesh.rotation.y = temp * 10.0f;
        mesh.Draw();

        camera.Stop();
    }

    return 0;
}
```

これを実行すると立体感のある三角形が回ります。Cameraクラスに追加したビュー行列と射影行列の説明をします。まずビュー行列というのはカメラの位置と角度の情報を持っている行列です。Meshクラスで追加したモデル行列と似ていますが、ビュー行列にはスケールの情報は入っていません。カメラなんでスケール入らないです。なのでビュー行列の計算はDirectX::XMMatrixScaling関数を使ってないこと以外はモデル行列とほぼ同じですよね。DirectX::XMMatrixInverseという関数が使われていますがこれは逆行列に変換する関数です。なぜ逆行列にするのかというと、カメラが動くとそれに映る物は逆に動きますよね。そういう理由で逆行列にするとビュー行列を計算できます。射影行列というのはコードでいうとprojectionMatrixのことで、立体感を出すための行列です。DirectX::XMMatrixPerspectiveFovLH関数を使っていますが、`DirectX::XMMatrixPerspectiveFovLH(視野角, アスペクト比, 物が映る最小の距離, 最大の距離)`という風に指定する関数です。視野角は見える範囲の角度です。人間は180°くらいですよね。多くのゲームは60°とか90°とかにしてるみたいです。アスペクト比を設定すれば今まで横に伸びていた三角形が、ちゃんと横に伸びずに描画されます。物が映る最小の距離と最大の距離は、物が映る距離の範囲で、範囲外は描画されません。Perspectiveというのは透視投影という意味です。これとは別に平行投影というものもあって、DirectX::XMMatrixOrthographicLH関数を使います。Orthographicが平行投影という意味で、遠近感のない行列を作れるので、2Dゲームとかに向いてますね。