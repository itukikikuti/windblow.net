---
layout: post
title: 行列で座標変換して三角形を動かす
category: DirectX11
date: 2018-11-10 00:00:00
---

次は三角形を動かしてみましょう。どうすれば動かせるんでしょうか。実は頂点を動かせば動きます。

``` cpp
    DirectX::XMFLOAT3 position;

    std::vector<Vertex> vertices;
    vertices.push_back(Vertex(DirectX::XMFLOAT3(position.x, position.y + 1.0f, position.z), DirectX::XMFLOAT3(1.0f, 1.0f, 0.0f)));
    vertices.push_back(Vertex(DirectX::XMFLOAT3(position.x + 1.0f, position.y - 1.0f, position.z), DirectX::XMFLOAT3(0.0f, 1.0f, 1.0f)));
    vertices.push_back(Vertex(DirectX::XMFLOAT3(position.x - 1.0f, position.y - 1.0f, position.z), DirectX::XMFLOAT3(1.0f, 0.0f, 1.0f)));
```

さっき使った3つ頂点の座標にpositionという変数を足してみました。こうすればpositionを動かせば三角形が移動しますよね。でもこのやり方だと、動かすたびに頂点バッファを作り直さないといけないので動作が重くなったり、回転や拡大縮小もしようとすると面倒くさいです。なので他のやり方にします。行列というものを使います。行列というのはお店の前にできる方じゃなくて、数学の方です。私は数学は中学の連立方程式までしかわからないので、詳しい説明は出来ませんが、行列を使うと座標変換が出来ます。「アフィン変換」でググってみてください。これと同じようなことをやれば、移動、回転、拡縮が簡単にできるみたいです。

行列はシェーダで使うので、まずはシェーダに行列を送れるようにしましょう。CBuffer.hppというファイルを作ってください。

<small>CBuffer.hpp</small>
``` cpp
#pragma once
#include <memory>
#include <d3d11.h>
#include <wrl.h>
#include "Graphics.hpp"

template <class T>
class CBuffer
{
public:
    CBuffer()
    {
        data = std::make_unique<T>();

        D3D11_BUFFER_DESC cbufferDesc = {};
        cbufferDesc.ByteWidth = sizeof(T);
        cbufferDesc.Usage = D3D11_USAGE_DEFAULT;
        cbufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
        Graphics::GetDevice().CreateBuffer(&cbufferDesc, nullptr, buffer.GetAddressOf());
    }
    T& Get()
    {
        return *data.get();
    }
    void Attach(int slot)
    {
        Graphics::GetContext().UpdateSubresource(buffer.Get(), 0, nullptr, data.get(), 0, 0);
        Graphics::GetContext().VSSetConstantBuffers(slot, 1, buffer.GetAddressOf());
        Graphics::GetContext().PSSetConstantBuffers(slot, 1, buffer.GetAddressOf());
    }

private:
    Microsoft::WRL::ComPtr<ID3D11Buffer> buffer;
    std::unique_ptr<T> data;
};
```

CBufferクラスはテンプレートクラスなのでヘッダファイルのみです。このクラスは定数バッファと使うためのクラスで、英語でいうとConstant BufferなのでCBufferという名前になってます。ID3D11Device::CreateBuffer関数で定数バッファを作って、ID3D11DeviceContext::UpdateSubresource関数で定数バッファの中身を更新して、ID3D11DeviceContext::VSSetConstantBuffers関数などで定数バッファを設定してます。そしたらMeshクラスにShaderData構造体と`CBuffer<ShaderData> shaderData;`をプライベートで追加してください。

<small>Mesh.hpp</small>
``` cpp
class Mesh
{
    …
private:
    struct ShaderData
    {
        DirectX::XMMATRIX modelMatrix;
    };

    CBuffer<ShaderData> shaderData;
    Microsoft::WRL::ComPtr<ID3D11Buffer> vertexBuffer;
};
```

さらにMesh::Draw関数をちょっと変えます。

<small>Mesh.cpp</small>
``` cpp
void Mesh::Draw()
{
    static float angle = 0.0f;
    angle += 0.1f;

    shaderData.Get().modelMatrix = DirectX::XMMatrixTranspose(
        DirectX::XMMatrixRotationZ(angle)
    );

    shaderData.Attach(0);

    shader.Attach();
    …
}
```

さらにシェーダも変えます。Shader::GetDefault関数の中です。

<small>Shader.cpp</small>
``` cpp
Shader Shader::GetDefault()
{
    static std::unique_ptr<Shader> shader(new Shader(
        "cbuffer Object : register(b0)"
        "{"
        "    matrix modelMatrix;"
        "};"
        "struct Vertex"
        …
        "Pixel VS(Vertex vertex)"
        "{"
        "    Pixel output;"
        "    output.position = mul(vertex.position, modelMatrix);"
        "    output.color = vertex.color;"
        "    return output;"
        "}"
        …
}
```

`cbuffer Object : register(b0)`を追加して、`output.position = mul(vertex.position, modelMatrix)`に変えました。

``` cpp
    DirectX::XMMATRIX translationMatrix = DirectX::XMMatrixTranslation(position.x, position.y, position.z);

    DirectX::XMMATRIX rotationMatrix = DirectX::XMMatrixRotationRollPitchYaw(
        DirectX::XMConvertToRadians(rotation.x),
        DirectX::XMConvertToRadians(rotation.y),
        DirectX::XMConvertToRadians(rotation.z)
    );

    DirectX::XMMATRIX scalingMatrix = DirectX::XMMatrixScaling(scale.x, scale.y, scale.z);

    DirectX::XMMATRIX modelMatrix = scalingMatrix * rotationMatrix * translationMatrix;
```

DirectX::XMMatrixTranslationで平行移動行列、DirectX::XMMatrixRotationRollPitchYawで回転行列、DirectX::XMMatrixScalingで拡大縮小行列を計算できます。この行列たちを掛け合わせることでモデル行列
