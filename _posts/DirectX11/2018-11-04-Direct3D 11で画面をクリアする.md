---
layout: post
title: Direct3D 11で画面をクリアする
category: DirectX11
date: 2018-11-04 00:00:01
---

次はDirect3D 11で画面をクリアしてみましょう。画面もうクリアじゃん、と思うかもしれませんね。私もそう思います、でも実際にはクリアできてません。今は何も描いていないから大丈夫ですが、なにか描画したときに画面をクリアしないと、前のフレームで描いたものが残ったままになってしまいます。それと画面のクリアするときに色を変えられるので、例えば背景色を赤くしたり出来ます。なので、割と重要です。画面をクリアするにはレンダーターゲットというものを使います。レンダーターゲットというのは紙みたいなもので、絵を描いたり真っ白にしたり出来るやつです。`CreateRenderTargetView`でレンダーターゲットを作って、`OMSetRenderTargets`で使うレンダーターゲットを設定して、`ClearRenderTargetView`でレンダーターゲットをまっさらにします。このときに背景色を変えられます。

``` cpp
    Microsoft::WRL::ComPtr<ID3D11Texture2D> texture = nullptr;
    Graphics::GetSwapChain().GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast<void**>(texture.GetAddressOf()));

    Microsoft::WRL::ComPtr<ID3D11RenderTargetView> renderTargetView = nullptr;
    Graphics::GetDevice().CreateRenderTargetView(texture.Get(), nullptr, renderTargetView.GetAddressOf());

    Graphics::GetContext().OMSetRenderTargets(1, renderTargetView.GetAddressOf(), nullptr);

    float clearColor[4] = { 1.0f, 0.0f, 0.0f, 1.0f };
    Graphics::GetContext().ClearRenderTargetView(renderTargetView.Get(), clearColor);
```

こんな感じです。画面を管理しているのはスワップチェインなので`GetSwapChain().GetBuffer`という関数でスワップチェインからテクスチャをもらいます。テクスチャというのは画像のデータです。もらったテクスチャを元にレンダーターゲットを作ります。その後レンダーターゲットをセットして赤でクリアしてます。`float clearColor[4] = { 1.0f, 0.0f, 0.0f, 1.0f };`というのは赤、緑、青、透明度の順番で並んでいて、青にしたいときは`{ 0.0f, 0.0f, 1.0f, 1.0f }`、黄色にしたいときは`{ 1.0f, 1.0f, 0.0f, 1.0f }`にします。こういうのをRGBAといったりします。

これを踏まえてCameraクラスを作ってみましょう。なぜカメラなのかは画面のクリアは普通カメラがするからです。もちろん普通じゃないことがいくらでもできるのがDirect3D 11なんですが、あくまで作例なのでなるべく無個性で癖のない感じのコードにしたいと私は思ってるので、超普通のコードを書いていきます。では、Camera.hppとCamera.cppというファイルを作ってください。

``` cpp
// Camera.hpp
#pragma once
#include <d3d11.h>
#include <wrl.h>

class Camera
{
public:
    Camera();
    ~Camera();
    void Start();
    void Stop();

private:
    Microsoft::WRL::ComPtr<ID3D11RenderTargetView> renderTargetView;
};
```

``` cpp
// Camera.cpp
#include "Window.hpp"
#include "Graphics.hpp"
#include "Camera.hpp"

Camera::Camera()
{
    Microsoft::WRL::ComPtr<ID3D11Texture2D> texture = nullptr;
    Graphics::GetSwapChain().GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast<void**>(texture.GetAddressOf()));

    Graphics::GetDevice().CreateRenderTargetView(texture.Get(), nullptr, renderTargetView.GetAddressOf());

    D3D11_VIEWPORT viewPort = {};
    viewPort.Width = Window::GetSize().x;
    viewPort.Height = Window::GetSize().y;
    viewPort.MaxDepth = 1.0f;
    Graphics::GetContext().RSSetViewports(1, &viewPort);
}

Camera::~Camera()
{
}

void Camera::Start()
{
    Graphics::GetContext().OMSetRenderTargets(1, renderTargetView.GetAddressOf(), nullptr);

    float clearColor[4] = { 1.0f, 0.0f, 0.0f, 1.0f };
    Graphics::GetContext().ClearRenderTargetView(renderTargetView.Get(), clearColor);
}

void Camera::Stop()
{
}
```

``` cpp
// Source.cpp
#include "Window.hpp"
#include "Graphics.hpp"

#include "Camera.hpp"

void Initialize()
{
    Window::Initialize();
    Graphics::Initialize();
}

bool Refresh()
{
    Graphics::Update();
    return Window::Update();
}

int APIENTRY wWinMain(HINSTANCE, HINSTANCE, LPWSTR, int)
{
    Initialize();

    Camera camera;

    while (Refresh())
    {
        camera.Start();
        // ここで描画
        camera.Stop();
    }

    return 0;
}
```

WindowクラスやGraphicsクラスはstaticな関数しかないクラスでしたが、Cameraクラスはオブジェクトとして使う感じになってるので、もちろん`Camera* camera = new Camera();`みたいにすれば動的に作れます。Start関数とStop関数の間で描画、みたいに使います。Stop関数は何もしてない関数ですが、今後描画したあとになにかしたいときはここに描いていきます。例えばポストエフェクトとかですね。（気になる人は調べてみてね）それにStartだけより、StartとStopがあったほうが、なんかわかり易くないですか？そういう理由でStopという空の関数を作ってます。ダウンロードしたい人はGitHubに[サンプルリポジトリ](https://github.com/itukikikuti/DirectX11Sample)があるので、ぜひダウンロードしてください。
