---
layout: post
title: Direct3D 11でシェーダをコンパイルする
category: DirectX11
date: 2018-11-05 00:00:00
---

Direct3D 11ではなにかを描画するのにプログラマブルシェーダというのを書かないといけません。シェーダは後でしっかりやるので今は、へぇこれがシェーダかー程度に思っておけばいいです。

```
struct Vertex
{
    float4 position : POSITION;
    float3 color : COLOR;
};

struct Pixel
{
    float4 position : SV_POSITION;
    float3 color : COLOR;
};

Pixel VS(Vertex vertex)
{
    Pixel output;
    output.position = vertex.position;
    output.color = vertex.color;
    return output;
}

float4 PS(Pixel pixel) : SV_TARGET
{
    return float4(pixel.color, 1);
}
```

これがシェーダです。このシェーダのソースコードを`D3DCompile`関数でコンパイルして使います。

``` cpp
    Microsoft::WRL::ComPtr<ID3DBlob> vertexShaderBlob = nullptr;
    D3DCompile(shaderSource.c_str(), shaderSource.length(), nullptr, nullptr, D3D_COMPILE_STANDARD_FILE_INCLUDE, "VS", "vs_5_0", D3DCOMPILE_ENABLE_STRICTNESS, 0, out.GetAddressOf(), nullptr);

    Microsoft::WRL::ComPtr<ID3D11VertexShader> vertexShader = nullptr;
    Graphics::GetDevice().CreateVertexShader(vertexShaderBlob->GetBufferPointer(), vertexShaderBlob->GetBufferSize(), nullptr, vertexShader.GetAddressOf());
```

こんな感じでシェーダのソースコードを文字列で渡して、最終的に`CreateVertexShader`関数で`ID3D11VertexShader`を作ります。これはVertexShaderという頂点を操作するシェーダなんですが、PixelShaderという色を操作するシェーダも同じように作ります。

それとインプットレイアウトというものも必要です。例えば三角形は3つの頂点があります。その頂点の内部データを決めるものがインプットレイアウトです。

``` cpp
    std::vector<D3D11_INPUT_ELEMENT_DESC> inputElementDesc
    {
        { "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
        { "COLOR", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },
    };

    Microsoft::WRL::ComPtr<ID3D11InputLayout> inputLayout = nullptr;
    Graphics::GetDevice().CreateInputLayout(inputElementDesc.data(), (UINT)inputElementDesc.size(), vertexShaderBlob->GetBufferPointer(), vertexShaderBlob->GetBufferSize(), inputLayout.GetAddressOf());
```

インプットレイアウトはこんな感じで作ります。inputElementDescを見てみると、POSITIONとCOLORというのがあります。POSITIONは頂点の座標です。COLORは頂点の色です。つまり頂点には座標と色のデータが入ってますという定義をしてる感じです。この辺も詳しくは後でシェーダと一緒に詳しくやります。

ではShaderクラスを作ってみましょう。Shader.hppとShader.cppというファイルを作ってください。

``` cpp
// Shader.hpp
#pragma once
#include <string>
#include <d3d11.h>
#include <d3dcompiler.h>
#include <wrl.h>
#pragma comment(lib, "d3dcompiler.lib")

class Shader
{
public:
    static Shader GetDefault();
    static void Compile(const std::string& source, const char* entryPoint, const char* shaderModel, ID3DBlob** out);

    Shader(const std::string& source);
    void Attach();

private:
    Microsoft::WRL::ComPtr<ID3D11VertexShader> vertexShader;
    Microsoft::WRL::ComPtr<ID3D11PixelShader> pixelShader;
    Microsoft::WRL::ComPtr<ID3D11InputLayout> inputLayout;
};
```

``` cpp
// Shader.cpp
#include <memory>
#include <vector>
#include "Graphics.hpp"
#include "Shader.hpp"

Shader Shader::GetDefault()
{
    static std::unique_ptr<Shader> shader(new Shader(
        "struct Vertex"
        "{"
        "    float4 position : POSITION;"
        "    float3 color : COLOR;"
        "};"
        "struct Pixel"
        "{"
        "    float4 position : SV_POSITION;"
        "    float3 color : COLOR;"
        "};"
        "Pixel VS(Vertex vertex)"
        "{"
        "    Pixel output;"
        "    output.position = vertex.position;"
        "    output.color = vertex.color;"
        "    return output;"
        "}"
        "float4 PS(Pixel pixel) : SV_TARGET"
        "{"
        "    return float4(pixel.color, 1);"
        "}"
    ));

    return *shader.get();
}

void Shader::Compile(const std::string& source, const char* entryPoint, const char* shaderModel, ID3DBlob** out)
{
    Microsoft::WRL::ComPtr<ID3DBlob> error = nullptr;
    D3DCompile(source.c_str(), source.length(), nullptr, nullptr, D3D_COMPILE_STANDARD_FILE_INCLUDE, entryPoint, shaderModel, D3DCOMPILE_ENABLE_STRICTNESS, 0, out, error.GetAddressOf());

    if (error != nullptr)
    {
        OutputDebugStringA((char*)error->GetBufferPointer());
        MessageBoxA(nullptr, (char*)error->GetBufferPointer(), "Shader error", MB_ICONERROR | MB_OK);
    }
}

Shader::Shader(const std::string& source)
{
    Microsoft::WRL::ComPtr<ID3DBlob> vertexShaderBlob = nullptr;
    Compile(source, "VS", "vs_5_0", vertexShaderBlob.GetAddressOf());

    Graphics::GetDevice().CreateVertexShader(vertexShaderBlob->GetBufferPointer(), vertexShaderBlob->GetBufferSize(), nullptr, vertexShader.GetAddressOf());

    Microsoft::WRL::ComPtr<ID3DBlob> pixelShaderBlob = nullptr;
    Compile(source, "PS", "ps_5_0", pixelShaderBlob.GetAddressOf());

    Graphics::GetDevice().CreatePixelShader(pixelShaderBlob->GetBufferPointer(), pixelShaderBlob->GetBufferSize(), nullptr, pixelShader.GetAddressOf());

    std::vector<D3D11_INPUT_ELEMENT_DESC> inputElementDesc
    {
        { "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
        { "COLOR", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },
    };

    Graphics::GetDevice().CreateInputLayout(inputElementDesc.data(), (UINT)inputElementDesc.size(), vertexShaderBlob->GetBufferPointer(), vertexShaderBlob->GetBufferSize(), inputLayout.GetAddressOf());
}

void Shader::Attach()
{
    Graphics::GetContext().VSSetShader(vertexShader.Get(), nullptr, 0);
    Graphics::GetContext().PSSetShader(pixelShader.Get(), nullptr, 0);
    Graphics::GetContext().IASetInputLayout(inputLayout.Get());
}
```

``` cpp
// Source.cpp
#include "Window.hpp"
#include "Graphics.hpp"

#include "Shader.hpp"
#include "Camera.hpp"

void Initialize()
{
    Window::Initialize();
    Graphics::Initialize();
}

bool Refresh()
{
    Graphics::Update();
    return Window::Update();
}

int APIENTRY wWinMain(HINSTANCE, HINSTANCE, LPWSTR, int)
{
    Initialize();

    Camera camera;

    while (Refresh())
    {
        camera.Start();
        // ここで描画
        camera.Stop();
    }

    return 0;
}
```

`#include <d3dcompiler.h>`というのがシェーダをコンパイルするためのヘッダファイルです。`D3DCompile`などが使えるようになります。`GetDefault`というstatic関数というのは、シェーダのコンパイルが結構遅いので同じシェーダを使い回せるようにするために、static変数でシェーダを作ってます。`Compile`関数にはエラーを表示する処理も書いてます。そして`Attach`関数を呼べばシェーダを使えます。今回も見た目が変わらないのでわかりにくいですが、これでやっと描画する準備が整いました。ダウンロードしたい人はGitHubに[サンプルリポジトリ](https://github.com/itukikikuti/DirectX11Sample)があるので、ぜひダウンロードしてください。
